\chapter{Implementace: Vývoj v App Engine}

\section{Výběr cloudu}
Pro praktickou ukázku a prověření implementace jsem vybral cloud App Engine od společnosti Google. Nejdůležitějším důvodem pro mne byla možnost nahrát plnohodnotnou aplikaci bez nutnosti vynaložení jakýchkoliv nákladů na hosting. Nastavené kvóty od kterých je nutné platit jsou vysoké (odpovídají několika stovkám tisíců požadavkům za den) a stále se spostupně zvyšují. Je tedy možné s tímto cloudem libovolně experimentovat a nahrávat různé testovací aplikace. Mnoho Java vývojářů hledá pro svoje malé aplikace hosting, kde by nemuseli platit, anebo mohli nahrát více aplikací. To je ale problém webového Java světa. Server počítá pouze s jedinou aplikací a je často nutné si pamatovat prostředky a další zdroje v rámci aplikace mezi požadavky. Javovský server tak počítá s tím, že si alokuje většinu dostupné paměti systému. Výhodou je, že nemusíme při každém požadavku vytvářet nové spojení do databáze a k ostatním prostředkům. Naproti tomu u skriptovací jazyků (jako například \verb|PHP| nebo \verb|Python|), se při každém požadavku provede celý kód znovu. Na serveru tak může běžet několik aplikací a zároveň se neovlivňují. V praxi se toho běžně využívá a proto je možné provozovat velké množství takovýchto aplikací na jediném hosting. App Engine nám umožňuje stejný princip pro Javu, běh více aplikací na stejném hardware. Cena za tuto možnost je nutnost uvolnění zdrojů z nepoužívaných aplikací, aby nezabírali místo ostatním. To App Engine sám hlídá a po určité době neaktivity aplikaci odstaví a nahraje aktivní.

\section{Aplikace}
Cílem této bakalářské práce je ověřit možnosti a omezení škálovatelných aplikací. Nejdůležitějším hlediskem je celková rychlost a odezva aplikace v závislosti na počtu souběžných požadavků. Tedy jak bude aplikace a celý cloud reagovat na zvýšený nápor požadavků, jak se s tím cloud vyrovná a zda bude služba stále poutžitelná. Také jsem se zaměřil na rychlost čtení a ukládání do Datastore, pokud je klasická aplikace vystavena vysoké zátěži, je právě databáze úzkým hrdlem (takzvaný \emph{bottleneck}) a přestává stíhat jako první. 

Kromě ověření rychlosti a škálovatelnosi bylo také cílem vytvořit rozsáhlejší aplikaci a vyzkoušet všechny úskalí, které nám platforma App Engine staví do cesty. To znamená implementace běžných požadavků na aplikace, například M:N\footnote{Many-to-Many - druh relace, kde více entit může být spojeno s více entitami (M:N), v relačních databázích je pro propojení použita spojovací tabulka} relace mezi entitami, zamykání dat proti přepsání a další požadavky, které jsou na aplikace běžně kladeny. Po vytvoření tohoto základu a překonání všech zádrhelů již bude jednoduché takovouto aplikaci upravit pro jiné požadavky, anebo rozšířit o nové funkce.

Jako nejvhodnější řešení pro vyzkoušení implementace jsem vybral jednoduchý systém pro správu obsahu (CMS - Content Management System). Můžeme si tak vytvořit webovou  stránku s plnou administrací, tedy s možností přidávání, úpravy a mazání stránek. Ke každé stránce můžeme přidat šablonu. Mimo samotných stránek lze přidávat, upravovat a mazat i novinky, jedná se o kratší zprávy, pro které je zbytečné vytvářet samostatnou stránku. Ke každé stránce lze také přiřadit štítek (tag), tato možnost nahrazuje kategorie. Výhodou oproti kategoriím, kde může být jeden článek pouze v jedné kategorii je, že článek může být označen více štítky a zároveň jeden štítek může být přiřazen k více článkům. Z těchto údajů pak můžeme generovat takzvané \emph{tag cloudy} (oblaky štítků)\footnote{http://en.wikipedia.org/wiki/Tag\_cloud}, kde velikost štítku určuje jeho význam, čim více článků štítek označuje, tím je důležitější a výraznější. Z hlediska implementace se jedná o vazbu M:N, která se v NoSQL databázích musí implementovat složitěji než v relačních a bylo potřeba vymyslet nejlepší řešení.

\section{Výběr frameworku: Slim3}
Než jsem začal aplikaci psát, zjišťoval jsem, které knihovny a frameworky\footnote{Framework je ucelený soubor knihoven a kódu pomáhající vytvořit aplikaci} bych mohl použít na ulehční práce. Kvůli omezením nejsou podporovány všechny knihovny a některé potřebují speciální úpravy anebo nastavení. Další nevýhodou je, že čím je náš kód rozsáhleší, tím déle bude trvat načítání, pokaždé když bude App Engine nahrávat aplikaci do aktivního stavu. Tímto jsem eliminoval známé, ale velké frameworky jako jsou Spring\footnote{Spring Framework - http://www.springsource.org/} a Seam\footnote{Seam Framework - http://seamframework.org/}. Poté jsem hledal mezi menšími, ale žádný nevyhovoval úplně potřebám App Engine. Bohužel je tento cloud relativně mladý a tak pro něj neexistují frameworky, anebo jsou málo známé. Myslel jsem tedy že použiji přímočaré řešení pomocí servletů a naprogramuji aplikaci od základů. Naštěstí jsem ale náhodou narazil na framework Slim3\footnote{Slim3 - http://sites.google.com/site/slim3appengine/} určený přesně pro potřeby App Engine.

Slim3 je MVC\footnote{Model View Controller - http://en.wikipedia.org/wiki/Model-view-controller}
framework optimalizovaný pro App Engine, přináší rozšíření i jednodušší práci s Datastore API a další vylepšení. Jeho hlavní koncepty jsou: \emph{simple} (jednoduchý) a \emph{less is more} (méně je více), tedy že jednoduchost a srozumitelnost vedou ke správnému designu. Framework se drží Paretova pravidla, tedy že 80\% aplikace, pramení z 20\% práce, takže se snaží co nejvíce zjednodušit oněch 20\% a ve zbytku nechává programátorovi volnost.

Nejvíce nám framework pomáhá při práci s Datastore. Pokud s uložištěm chceme pracovat, máme na App Engine možnost použít klasické JPA\footnote{JPA - Java Presistence API - http://en.wikipedia.org/wiki/Java\_Persistence\_API} s těmito omezeními: nemůžeme použít vztah \verb|many-to-many|, v dotazu nemůžeme použít \verb|JOIN| a agregační funkce ( \verb|GROUP BY|,  \verb|HAVING|,  \verb|SUM|,  \verb|AVG|,  \verb|MAX| a  \verb|MIN|) a polymorfické dotazy (slouží k získání podtřídy). Druhou možností je použít JDO\footnote{JDO - Java Data Obects - http://en.wikipedia.org/wiki/Java\_Data\_Objects}, jedná se o obecněší obdobu JPA, kde můžeme náš doménový model ukládat do různých uložišť - relačních, nerelačních, objektových databází,  XML i do obyčejných souborů. Programátorská práce je stejná jako s JPA, definujeme model pomocí anotací\footnote{Anotace v Jazyce java představují speciální konstrukce začínající @ a přidávající ke kódu dále zpracovatelné metainformace} a dotazujeme se pomocí objektu \verb|Query|. Poslední možností je použít přímo Datastore API, které je optimalizované pro práci s BigTable, Dovoluje nám měnit strukturu entit za běhu. Znamená to, že se nemůžeme spolehnout na to, že je daný sloupec v entitě obsažen, ani na jeho typ. Sloupce u entity je vlastně kolekce objektů, v Javě by BigTable vypadala následovně: \verb|Map<Key, Set<Object>>|. Toto je důležité uvědomit si a může nám to přinést potíže v začátcích, dobrou radou je ukládat si přímo do objektu i verzi schématu, při změně v aplikaci se totiž schémata uložených entit nezmění. 

Další změnou jsou transakce, pro správné fungování potřebujeme, aby byl všechny typy entity používané v transakci na jednom stroji. Toto může být problém, jelikož Google má několik datacenter a není tak jisté, že budou všechny entity pohromadě. Kvůli tomuto zavádí App Engine takzvané \emph{entity groups} (skupiy entit). Entity přiřadíme do stejné skupiny tak, že nové entitě nastavíme tzv. \emph{parent entity} (rodičovskou entitu), její klíč pak bude složen z kílče samotné entity a klíče rodičovské entity. Pokud se pokusíe provést operace v tansakci na entitách z rozdílných skupin, vyhodí App Engine výjimku.
